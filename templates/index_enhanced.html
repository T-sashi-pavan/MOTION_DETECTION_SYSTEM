<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>üéØ Motion Detection System</title>
<style>
    *{box-sizing:border-box;margin:0;padding:0}
    body{
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
        color:#fff;min-height:100vh;display:flex;flex-direction:column;
    }
    .header{text-align:center;padding:20px;background:rgba(0,0,0,0.18);backdrop-filter:blur(6px)}
    .header h1{font-size:2.2em;margin-bottom:6px;text-shadow:2px 2px 4px rgba(0,0,0,.4)}
    .header p{opacity:.9}
    .container{flex:1;display:flex;flex-direction:column;align-items:center;padding:28px 18px;max-width:1200px;margin:0 auto;width:100%}
    .video-container{background:rgba(0,0,0,.28);border-radius:14px;padding:18px;backdrop-filter: blur(8px);border:1px solid rgba(255,255,255,.06);box-shadow:0 10px 30px rgba(0,0,0,.25);margin-bottom:26px;width:100%;max-width:880px}
    .video-wrapper{position:relative;display:inline-block;width:100%}
    video#video{display:block;width:100%;height:auto;border-radius:10px;box-shadow:0 8px 20px rgba(0,0,0,.35)}
    canvas#overlay{position:absolute;left:0;top:0;pointer-events:none;border-radius:10px}
    .controls{display:flex;gap:16px;flex-wrap:wrap;justify-content:center;margin:18px 0}
    .btn{padding:12px 26px;border:none;border-radius:8px;font-size:1em;font-weight:600;cursor:pointer;transition:all .22s;min-width:160px}
    .btn-start{background:linear-gradient(45deg,#4caf50,#66bb6a);color:#fff}
    .btn-stop{background:linear-gradient(45deg,#f44336,#e57373);color:#fff}
    .stats{background:rgba(0,0,0,.36);border-radius:12px;padding:20px;backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.06);text-align:center;width:100%;max-width:880px}
    .stats h3{margin-bottom:14px;color:#b3e5fc;font-size:1.2em}
    .stats-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:14px}
    .stat-item{background:rgba(255,255,255,.06);padding:14px;border-radius:8px}
    .stat-value{font-size:1.8em;font-weight:700;color:#4caf50;margin-bottom:4px;text-shadow:0 2px 4px rgba(0,0,0,.3)}
    .stat-label{font-size:.85em;opacity:.85;text-transform:uppercase;letter-spacing:1px}
    .detection-info{margin-top:12px;background:rgba(0,0,0,.55);padding:12px;border-radius:8px;border-left:4px solid #4caf50}
    .detection-method{display:inline-block;background:rgba(76,175,80,.16);color:#c8e6c9;padding:6px 10px;border-radius:14px;margin:4px;font-size:.8em}
    .placeholder{width:100%;height:450px;background:rgba(0,0,0,.6);display:flex;align-items:center;justify-content:center;border-radius:10px;border:2px dashed rgba(255,255,255,.12)}
    @media(max-width:768px){.btn{width:100%;max-width:320px}}
</style>
</head>
<body>
  <div class="header">
    <h1>üéØ Motion Detection System</h1>
    <p>Simple and Accurate Human Detection - Real-time Green Box Tracking</p>
  </div>

  <div class="container">
    <div class="video-container">
      <div class="video-wrapper" id="video-section">
        <div class="placeholder" id="placeholder">
          <div style="text-align:center;color:rgba(255,255,255,.88)">
            <h3>üì∑ Motion Detection Ready</h3>
            <p>Click "Start Detection" to begin</p>
            <p><small>Allow camera access when prompted</small></p>
          </div>
        </div>
      </div>
    </div>

    <div class="controls">
      <button id="start-btn" class="btn btn-start">üé¨ Start Detection</button>
      <button id="stop-btn" class="btn btn-stop" disabled>‚èπ Stop Detection</button>
    </div>

    <div class="stats">
      <h3>üìä Motion Detection Statistics</h3>
      <div class="stats-grid">
        <div class="stat-item">
          <div id="people-count" class="stat-value">0</div>
          <div class="stat-label">People Detected</div>
        </div>
        <div class="stat-item">
          <div id="frame-count" class="stat-value">0</div>
          <div class="stat-label">Frames Processed</div>
        </div>
        <div class="stat-item">
          <div id="detection-rate" class="stat-value">0</div>
          <div class="stat-label">Detections / Min</div>
        </div>
        <div class="stat-item">
          <div id="motion-intensity" class="stat-value">0</div>
          <div class="stat-label">Motion Intensity</div>
        </div>
      </div>

      <div class="detection-info">
        <h4 style="margin:0 0 8px 0">üî¨ Detection Methods Active:</h4>
        <div id="detection-methods">
          <span class="detection-method">Frame Differencing</span>
          <span class="detection-method">Blob Clustering</span>
          <span class="detection-method">Overlap Removal</span>
        </div>
        <p style="margin-top:8px"><strong>Status:</strong> <span id="status-text">System Ready</span></p>
      </div>
    </div>
  </div>

<script>
/*
 Improved client-side motion detection:
 - Downscales frames to a small grid to perform fast differencing
 - Performs connected-component (BFS) on the small motion mask to find blobs
 - Converts small-boxes back to original video coordinates and draws green boxes
 - Keeps stats: frames processed, detections/min, motion intensity
*/

class MotionDetector {
  constructor() {
    // DOM
    this.startBtn = document.getElementById('start-btn');
    this.stopBtn = document.getElementById('stop-btn');
    this.videoSection = document.getElementById('video-section');
    this.placeholder = document.getElementById('placeholder');

    this.peopleCountEl = document.getElementById('people-count');
    this.frameCountEl = document.getElementById('frame-count');
    this.detectionRateEl = document.getElementById('detection-rate');
    this.motionIntensityEl = document.getElementById('motion-intensity');
    this.statusTextEl = document.getElementById('status-text');

    // video/canvases
    this.video = null;
    this.overlay = null; // overlay canvas to draw boxes
    this.octx = null;
    this.offscreen = null; // downscale canvas (processing)
    this.o2d = null;

    // state
    this.stream = null;
    this.running = false;
    this.prevImage = null; // Uint8ClampedArray of previous downscaled grayscale
    this.frameCount = 0;
    this.detectionCount = 0;
    this.peopleDetected = 0;
    this.motionIntensity = 0;
    this.startTime = null;

    // parameters
    this.downscaleFactor = 0.25; // reduce size for speed (25% of original)
    this.motionThreshold = 22; // pixel diff threshold (0-255)
    this.minBlobSize = 40; // minimum pixels in downscaled mask to consider a blob
    this.maxWorkers = 1;

    // bind
    this.startBtn.onclick = () => this.start();
    this.stopBtn.onclick = () => this.stop();

    // rAF handle
    this._raf = null;
  }

  async start() {
    try {
      this.startBtn.disabled = true;
      this.startBtn.textContent = 'üîÑ Starting...';
      this.updateStatus('Requesting camera permission...');

      // camera constraints - prefer user-facing camera
      const constraints = {
        audio: false,
        video: {
          width: { ideal: 640 },
          height: { ideal: 480 },
          facingMode: 'user'
        }
      };

      this.stream = await navigator.mediaDevices.getUserMedia(constraints);

      // create video element
      this.video = document.createElement('video');
      this.video.id = 'video';
      this.video.autoplay = true;
      this.video.playsInline = true;
      this.video.muted = true;
      this.video.srcObject = this.stream;

      // create overlay canvas
      this.overlay = document.createElement('canvas');
      this.overlay.id = 'overlay';
      this.overlay.style.width = '100%';
      this.overlay.style.height = 'auto';
      this.octx = this.overlay.getContext('2d', { alpha: true });

      // attach wrapper
      const wrapper = document.createElement('div');
      wrapper.className = 'video-wrapper';
      wrapper.style.position = 'relative';
      wrapper.appendChild(this.video);
      wrapper.appendChild(this.overlay);

      this.videoSection.innerHTML = '';
      this.videoSection.appendChild(wrapper);

      // wait for video metadata
      await new Promise(resolve => {
        this.video.onloadedmetadata = () => {
          // set overlay size to match video resolution
          this.overlay.width = this.video.videoWidth;
          this.overlay.height = this.video.videoHeight;
          this.overlay.style.width = '';
          this.overlay.style.height = '';
          resolve();
        };
      });

      // create downscale canvas for processing
      this.offscreen = document.createElement('canvas');
      this.offscreen.width = Math.max(16, Math.round(this.video.videoWidth * this.downscaleFactor));
      this.offscreen.height = Math.max(16, Math.round(this.video.videoHeight * this.downscaleFactor));
      this.o2d = this.offscreen.getContext('2d');

      // reset stats
      this.frameCount = 0;
      this.detectionCount = 0;
      this.peopleDetected = 0;
      this.motionIntensity = 0;
      this.startTime = Date.now();

      this.updateStatus('DETECTION ACTIVE - MONITORING FOR MOTION');
      this.startBtn.textContent = 'üé¨ Start Detection';
      this.stopBtn.disabled = false;
      this.running = true;

      // start loop
      this._raf = requestAnimationFrame(() => this.loop());
    } catch (err) {
      console.error(err);
      alert('Camera access was denied or not available: ' + err.message);
      this.startBtn.disabled = false;
      this.startBtn.textContent = 'üé¨ Start Detection';
      this.updateStatus('Camera access error');
    }
  }

  stop() {
    this.running = false;
    this.startBtn.disabled = false;
    this.stopBtn.disabled = true;
    this.updateStatus('DETECTION STOPPED');

    if (this.stream) {
      this.stream.getTracks().forEach(t => t.stop());
      this.stream = null;
    }

    if (this._raf) {
      cancelAnimationFrame(this._raf);
      this._raf = null;
    }

    // clear overlay
    if (this.octx && this.overlay) {
      this.octx.clearRect(0, 0, this.overlay.width, this.overlay.height);
    }

    // reset display to placeholder
    this.videoSection.innerHTML = `
      <div class="placeholder" id="placeholder">
        <div style="text-align:center;color:rgba(255,255,255,.88)">
          <h3>üì∑ Motion Detection Ready</h3>
          <p>Click "Start Detection" to begin</p>
          <p><small>Allow camera access when prompted</small></p>
        </div>
      </div>`;

    // reset stats
    this.peopleCountEl.textContent = 0;
    this.frameCountEl.textContent = 0;
    this.detectionRateEl.textContent = 0;
    this.motionIntensityEl.textContent = 0;

    this.prevImage = null;
  }

  loop() {
    if (!this.running) return;

    // process one frame
    this.frameCount++;
    this.processFrame();

    // schedule next
    this._raf = requestAnimationFrame(() => this.loop());
  }

  processFrame() {
    if (!this.video || this.video.videoWidth === 0) return;

    // draw downscaled frame into offscreen canvas
    this.o2d.drawImage(this.video, 0, 0, this.offscreen.width, this.offscreen.height);

    // get image data (small)
    const img = this.o2d.getImageData(0, 0, this.offscreen.width, this.offscreen.height);
    const w = img.width, h = img.height;
    const data = img.data;

    // convert to grayscale fast and compare with previous grayscale
    const gray = new Uint8ClampedArray(w * h);

    // compute grayscale
    for (let i = 0, p = 0; i < data.length; i += 4, p++) {
      // luminance formula
      gray[p] = (0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]) | 0;
    }

    let motionMask = new Uint8Array(w * h); // 0/1 mask
    let motionPixelCount = 0;

    if (this.prevImage) {
      // compute absolute difference and threshold
      for (let i = 0; i < gray.length; i++) {
        const diff = Math.abs(gray[i] - this.prevImage[i]);
        if (diff > this.motionThreshold) {
          motionMask[i] = 1;
          motionPixelCount++;
        }
      }
    } else {
      // first frame: no diff, but keep prevImage for next time
    }

    // store current as previous for next loop
    this.prevImage = gray;

    // determine motion intensity (scaled)
    this.motionIntensity = motionPixelCount;

    // cluster connected regions in the downscaled mask using BFS
    const blobs = this._findBlobs(motionMask, w, h, this.minBlobSize);

    // convert small-blob boxes to original video coordinates and draw
    const boxes = blobs.map(b => this._scaleBox(b, w, h, this.overlay.width, this.overlay.height));

    // optionally perform merging/overlap removal (we already use blob connectivity)
    // draw boxes on overlay
    this._drawBoxes(boxes);

    // update counts
    this.peopleDetected = boxes.length;
    if (boxes.length > 0) this.detectionCount++;

    // update UI stats
    this._updateStats();
  }

  _findBlobs(mask, w, h, minSize) {
    // BFS/4-neighbor connected components
    const visited = new Uint8Array(w * h);
    const blobs = [];
    const stack = [];

    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const idx = y * w + x;
        if (mask[idx] && !visited[idx]) {
          // new component
          let minX = x, minY = y, maxX = x, maxY = y, count = 0;
          stack.push(idx);
          visited[idx] = 1;

          while (stack.length) {
            const cur = stack.pop();
            const cy = Math.floor(cur / w);
            const cx = cur % w;
            count++;
            if (cx < minX) minX = cx;
            if (cx > maxX) maxX = cx;
            if (cy < minY) minY = cy;
            if (cy > maxY) maxY = cy;

            // 4-neighbors
            const neighbors = [
              cur - 1, cur + 1,
              cur - w, cur + w
            ];
            for (let nb of neighbors) {
              if (nb >= 0 && nb < w * h && !visited[nb] && mask[nb]) {
                visited[nb] = 1;
                stack.push(nb);
              }
            }
          }

          // filter small regions
          if (count >= minSize) {
            blobs.push({
              x: minX,
              y: minY,
              width: (maxX - minX + 1),
              height: (maxY - minY + 1),
              pixelCount: count
            });
          }
        }
      }
    }

    return blobs;
  }

  _scaleBox(box, sw, sh, tw, th) {
    // from small (sw,sh) to target (tw,th)
    const scaleX = tw / sw;
    const scaleY = th / sh;
    const x = Math.round(box.x * scaleX);
    const y = Math.round(box.y * scaleY);
    const width = Math.round(box.width * scaleX);
    const height = Math.round(box.height * scaleY);

    // pad box a bit (human shape)
    const padX = Math.round(width * 0.12);
    const padY = Math.round(height * 0.08);

    return {
      x: Math.max(0, x - padX),
      y: Math.max(0, y - padY),
      width: Math.min(tw - x + padX, width + padX * 2),
      height: Math.min(th - y + padY, height + padY * 2),
      pixels: box.pixelCount
    };
  }

  _drawBoxes(boxes) {
    // clear overlay
    this.octx.clearRect(0, 0, this.overlay.width, this.overlay.height);

    if (!boxes || boxes.length === 0) {
      // optionally show status overlay
      this.octx.fillStyle = 'rgba(0,0,0,0.45)';
      this.octx.fillRect(8, 8, 280, 44);
      this.octx.fillStyle = '#00FF00';
      this.octx.font = 'bold 16px Arial';
      this.octx.fillText('STATUS: NO MOTION DETECTED', 16, 34);
      return;
    }

    // draw boxes and labels
    boxes.forEach((b, i) => {
      this.octx.lineWidth = 4;
      this.octx.strokeStyle = '#00FF00';
      this.octx.fillStyle = '#00FF00';
      this.octx.beginPath();
      this.octx.rect(b.x, b.y, b.width, b.height);
      this.octx.stroke();

      // label
      this.octx.font = 'bold 18px Arial';
      this.octx.fillStyle = '#00FF00';
      const label = `Person ${i + 1}`;
      this.octx.fillText(label, b.x + 6, Math.max(18, b.y - 8));
    });

    // summary overlay
    this.octx.fillStyle = 'rgba(0,0,0,0.6)';
    this.octx.fillRect(8, 8, 380, 56);
    this.octx.fillStyle = '#00FF00';
    this.octx.font = 'bold 18px Arial';
    this.octx.fillText(`People Detected: ${boxes.length}`, 16, 34);
    this.octx.fillText('STATUS: HUMAN MOTION DETECTED', 16, 54);
  }

  _updateStats() {
    this.peopleCountEl.textContent = this.peopleDetected;
    this.frameCountEl.textContent = this.frameCount;

    const elapsedMinutes = Math.max(0.0001, (Date.now() - this.startTime) / 60000);
    const rate = Math.round(this.detectionCount / elapsedMinutes);
    this.detectionRateEl.textContent = rate;

    // motion intensity normalized for display
    this.motionIntensityEl.textContent = this.motionIntensity;
  }

  updateStatus(msg) {
    this.statusTextEl.textContent = msg;
  }
}

// init
document.addEventListener('DOMContentLoaded', () => {
  const detector = new MotionDetector();
});
</script>
</body>
</html>
