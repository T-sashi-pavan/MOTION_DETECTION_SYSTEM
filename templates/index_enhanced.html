<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Human Motion Detection System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }
        
        .container {
            text-align: center;
            padding: 20px;
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 95%;
            width: 100%;
            max-width: 900px;
        }
        
        h1 {
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #00ff00, #0099ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .video-container {
            position: relative;
            margin: 20px 0;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }
        
        #videoElement {
            width: 100%;
            max-width: 640px;
            height: auto;
            display: block;
            background: #000;
        }
        
        #canvasElement {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .controls {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(45deg, #00ff00, #0099ff);
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            box-shadow: 0 4px 15px rgba(0, 255, 0, 0.3);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 0, 0.4);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn.stop {
            background: linear-gradient(45deg, #ff4757, #ff6b7a);
            box-shadow: 0 4px 15px rgba(255, 71, 87, 0.3);
        }
        
        .btn.reset {
            background: linear-gradient(45deg, #ffa502, #ff6348);
            box-shadow: 0 4px 15px rgba(255, 165, 2, 0.3);
        }
        
        .status {
            margin: 20px 0;
            padding: 15px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .status-text {
            font-size: 1.4em;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.3em;
            font-weight: bold;
            color: #00ff00;
        }
        
        .detected {
            color: #00ff00;
        }
        
        .not-detected {
            color: #ff4757;
        }
        
        .error {
            color: #ff4757;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 71, 87, 0.2);
            border-radius: 8px;
            border: 1px solid rgba(255, 71, 87, 0.3);
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2em;
            }
            
            .container {
                margin: 10px;
                padding: 15px;
            }
            
            .btn {
                padding: 10px 20px;
                font-size: 14px;
            }
            
            .stats {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ Enhanced Human Motion Detection</h1>
        
        <div class="video-container">
            <video id="videoElement" autoplay muted playsinline></video>
            <canvas id="canvasElement"></canvas>
        </div>
        
        <div class="controls">
            <button class="btn" id="startBtn" onclick="startDetection()">üöÄ Start Detection</button>
            <button class="btn stop" id="stopBtn" onclick="stopDetection()">‚èπÔ∏è Stop Detection</button>
            <button class="btn reset" id="resetBtn" onclick="resetDetection()">üîÑ Reset System</button>
        </div>
        
        <div class="status">
            <div class="status-text" id="statusText">Click "Start Detection" to begin</div>
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">People Detected</div>
                    <div class="stat-value" id="peopleCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Frame Count</div>
                    <div class="stat-value" id="frameCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Detection Status</div>
                    <div class="stat-value" id="detectionStatus">Ready</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Camera Status</div>
                    <div class="stat-value" id="cameraStatus">Disconnected</div>
                </div>
            </div>
        </div>
        
        <div id="errorMessage" class="error" style="display: none;"></div>
    </div>

    <script>
        let video, canvas, ctx;
        let isDetecting = false;
        let frameCount = 0;
        let previousFrame = null;
        let backgroundFrame = null;
        let frameHistory = [];
        let detectedPeople = [];
        let animationFrame;
        
        // Enhanced detection parameters (matching motion_detection_CV.py)
        const DETECTION_CONFIG = {
            motionThreshold: 25,
            minContourArea: 1500,
            maxContourArea: 50000,
            humanAspectRatioMin: 1.2,
            humanAspectRatioMax: 4.0,
            minWidth: 30,
            minHeight: 60,
            maxWidth: 300,
            maxHeight: 500,
            skinDetectionThreshold: 0.02,
            overlapThreshold: 0.3,
            backgroundLearningRate: 0.01,
            stabilizationFrames: 30
        };

        async function initializeCamera() {
            try {
                video = document.getElementById('videoElement');
                canvas = document.getElementById('canvasElement');
                ctx = canvas.getContext('2d');
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        frameRate: { ideal: 30 }
                    }
                });
                
                video.srcObject = stream;
                
                video.addEventListener('loadedmetadata', () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    updateStatus('cameraStatus', 'Connected', 'detected');
                });
                
                return true;
            } catch (error) {
                showError('Camera access denied or not available: ' + error.message);
                updateStatus('cameraStatus', 'Error', 'not-detected');
                return false;
            }
        }

        function updateStatus(elementId, text, className = '') {
            const element = document.getElementById(elementId);
            element.textContent = text;
            element.className = 'stat-value ' + className;
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }

        function getImageData(video) {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = video.videoWidth;
            tempCanvas.height = video.videoHeight;
            tempCtx.drawImage(video, 0, 0);
            return tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        }

        function rgbToHsv(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const diff = max - min;
            
            let h = 0;
            if (diff !== 0) {
                if (max === r) h = ((g - b) / diff) % 6;
                else if (max === g) h = (b - r) / diff + 2;
                else h = (r - g) / diff + 4;
            }
            h = Math.round(h * 60);
            if (h < 0) h += 360;
            
            const s = max === 0 ? 0 : diff / max;
            const v = max;
            
            return [h, s * 100, v * 100];
        }

        function detectSkinColor(imageData, x, y, w, h) {
            let skinPixels = 0;
            let totalPixels = w * h;
            
            for (let dy = 0; dy < h; dy += 2) {
                for (let dx = 0; dx < w; dx += 2) {
                    const pixelIndex = ((y + dy) * imageData.width + (x + dx)) * 4;
                    if (pixelIndex >= 0 && pixelIndex < imageData.data.length - 3) {
                        const r = imageData.data[pixelIndex];
                        const g = imageData.data[pixelIndex + 1];
                        const b = imageData.data[pixelIndex + 2];
                        
                        const [h, s, v] = rgbToHsv(r, g, b);
                        
                        // Skin color detection in HSV (matching motion_detection_CV.py)
                        if (h >= 0 && h <= 20 && s >= 20 && s <= 100 && v >= 70 && v <= 100) {
                            skinPixels++;
                        }
                    }
                }
            }
            
            return (skinPixels / (totalPixels / 4)) > DETECTION_CONFIG.skinDetectionThreshold;
        }

        function isHumanShape(contour) {
            const { x, y, width: w, height: h, area } = contour;
            
            // Aspect ratio check (matching motion_detection_CV.py)
            const aspectRatio = h / w;
            if (aspectRatio < DETECTION_CONFIG.humanAspectRatioMin || 
                aspectRatio > DETECTION_CONFIG.humanAspectRatioMax) {
                return false;
            }
            
            // Size filtering (matching motion_detection_CV.py)
            if (w < DETECTION_CONFIG.minWidth || h < DETECTION_CONFIG.minHeight ||
                w > DETECTION_CONFIG.maxWidth || h > DETECTION_CONFIG.maxHeight) {
                return false;
            }
            
            // Area filtering (matching motion_detection_CV.py)
            if (area < DETECTION_CONFIG.minContourArea || area > DETECTION_CONFIG.maxContourArea) {
                return false;
            }
            
            return true;
        }

        function calculateContours(currentFrame, previousFrame) {
            const contours = [];
            const width = currentFrame.width;
            const height = currentFrame.height;
            const currentData = currentFrame.data;
            const previousData = previousFrame.data;
            
            // Create difference image (background subtraction simulation)
            const diffData = new Uint8ClampedArray(currentData.length);
            for (let i = 0; i < currentData.length; i += 4) {
                const diff = Math.abs(
                    (currentData[i] + currentData[i + 1] + currentData[i + 2]) / 3 -
                    (previousData[i] + previousData[i + 1] + previousData[i + 2]) / 3
                );
                
                const binary = diff > DETECTION_CONFIG.motionThreshold ? 255 : 0;
                diffData[i] = diffData[i + 1] = diffData[i + 2] = binary;
                diffData[i + 3] = 255;
            }
            
            // Simple blob detection (simulating contour detection)
            const visited = new Array(width * height).fill(false);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const index = y * width + x;
                    const pixelIndex = index * 4;
                    
                    if (!visited[index] && diffData[pixelIndex] === 255) {
                        const blob = floodFill(diffData, visited, x, y, width, height);
                        
                        if (blob.points.length > 50) {
                            const boundingBox = calculateBoundingBox(blob.points);
                            boundingBox.area = blob.points.length;
                            
                            if (isHumanShape(boundingBox)) {
                                contours.push(boundingBox);
                            }
                        }
                    }
                }
            }
            
            return contours;
        }

        function floodFill(data, visited, startX, startY, width, height) {
            const stack = [[startX, startY]];
            const points = [];
            
            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const index = y * width + x;
                
                if (x < 0 || x >= width || y < 0 || y >= height || 
                    visited[index] || data[index * 4] !== 255) {
                    continue;
                }
                
                visited[index] = true;
                points.push([x, y]);
                
                // 4-connected neighbors
                stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }
            
            return { points };
        }

        function calculateBoundingBox(points) {
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;
            
            for (const [x, y] of points) {
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }
            
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }

        function removeOverlappingBoxes(boxes) {
            if (boxes.length <= 1) return boxes;
            
            // Sort by area (larger first) - matching motion_detection_CV.py
            boxes.sort((a, b) => (b.width * b.height) - (a.width * a.height));
            
            const keep = [];
            
            for (let i = 0; i < boxes.length; i++) {
                const currentBox = boxes[i];
                let shouldKeep = true;
                
                for (const keptBox of keep) {
                    const overlap = calculateOverlap(currentBox, keptBox);
                    if (overlap > DETECTION_CONFIG.overlapThreshold) {
                        shouldKeep = false;
                        break;
                    }
                }
                
                if (shouldKeep) {
                    keep.push(currentBox);
                }
            }
            
            return keep;
        }

        function calculateOverlap(box1, box2) {
            const x1 = Math.max(box1.x, box2.x);
            const y1 = Math.max(box1.y, box2.y);
            const x2 = Math.min(box1.x + box1.width, box2.x + box2.width);
            const y2 = Math.min(box1.y + box1.height, box2.y + box2.height);
            
            if (x2 <= x1 || y2 <= y1) return 0;
            
            const intersection = (x2 - x1) * (y2 - y1);
            const area1 = box1.width * box1.height;
            const area2 = box2.width * box2.height;
            const union = area1 + area2 - intersection;
            
            return intersection / union;
        }

        function enhancedMotionDetection() {
            if (!isDetecting) return;
            
            frameCount++;
            updateStatus('frameCount', frameCount.toString());
            
            const currentFrame = getImageData(video);
            
            if (previousFrame && frameCount > DETECTION_CONFIG.stabilizationFrames) {
                // Motion-based detection (simulating MOG2 background subtraction)
                const motionContours = calculateContours(currentFrame, previousFrame);
                
                // Enhanced filtering with skin detection (matching motion_detection_CV.py)
                const validContours = [];
                for (const contour of motionContours) {
                    if (detectSkinColor(currentFrame, contour.x, contour.y, contour.width, contour.height)) {
                        validContours.push(contour);
                    }
                }
                
                // Remove overlapping detections (matching motion_detection_CV.py)
                detectedPeople = removeOverlappingBoxes(validContours);
                
                // Update display
                updateStatus('peopleCount', detectedPeople.length.toString());
                
                if (detectedPeople.length > 0) {
                    updateStatus('detectionStatus', 'HUMAN DETECTED', 'detected');
                    document.getElementById('statusText').textContent = 'STATUS: HUMAN MOTION DETECTED';
                    document.getElementById('statusText').className = 'status-text detected';
                } else {
                    updateStatus('detectionStatus', 'NO HUMAN', 'not-detected');
                    document.getElementById('statusText').textContent = 'STATUS: NO HUMAN DETECTED';
                    document.getElementById('statusText').className = 'status-text not-detected';
                }
                
                // Draw detection results
                drawDetections();
            }
            
            previousFrame = currentFrame;
            
            if (isDetecting) {
                animationFrame = requestAnimationFrame(enhancedMotionDetection);
            }
        }

        function drawDetections() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw bounding boxes for detected people (matching motion_detection_CV.py)
            detectedPeople.forEach((person, index) => {
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 3;
                ctx.strokeRect(person.x, person.y, person.width, person.height);
                
                // Draw person label (matching motion_detection_CV.py)
                ctx.fillStyle = '#00ff00';
                ctx.font = 'bold 16px Arial';
                ctx.fillText(`Person ${index + 1}`, person.x, person.y - 10);
            });
            
            // Draw statistics overlay (matching motion_detection_CV.py)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 10, 280, 60);
            
            ctx.fillStyle = '#00ff00';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(`People Detected: ${detectedPeople.length}`, 20, 30);
            ctx.fillText(`Frame: ${frameCount}`, 20, 50);
        }

        async function startDetection() {
            if (isDetecting) return;
            
            const cameraInitialized = await initializeCamera();
            if (!cameraInitialized) return;
            
            isDetecting = true;
            frameCount = 0;
            detectedPeople = [];
            
            updateStatus('detectionStatus', 'Starting...', 'detected');
            document.getElementById('statusText').textContent = 'Initializing Enhanced Detection System...';
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            
            enhancedMotionDetection();
        }

        function stopDetection() {
            isDetecting = false;
            
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
            
            if (video && video.srcObject) {
                const tracks = video.srcObject.getTracks();
                tracks.forEach(track => track.stop());
                video.srcObject = null;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            updateStatus('detectionStatus', 'Stopped', 'not-detected');
            updateStatus('cameraStatus', 'Disconnected', 'not-detected');
            document.getElementById('statusText').textContent = 'Detection Stopped';
            document.getElementById('statusText').className = 'status-text not-detected';
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }

        function resetDetection() {
            stopDetection();
            
            frameCount = 0;
            detectedPeople = [];
            previousFrame = null;
            backgroundFrame = null;
            frameHistory = [];
            
            updateStatus('peopleCount', '0');
            updateStatus('frameCount', '0');
            updateStatus('detectionStatus', 'Ready');
            document.getElementById('statusText').textContent = 'System Reset - Click "Start Detection" to begin';
            document.getElementById('statusText').className = 'status-text';
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('stopBtn').disabled = true;
            updateStatus('detectionStatus', 'Ready');
            updateStatus('cameraStatus', 'Disconnected', 'not-detected');
        });
    </script>
</body>
</html>
